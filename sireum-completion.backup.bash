#/usr/bin/env bash

# AUTOCOMPLETE TIPS (source: https://iridakos.com/programming/2018/03/01/bash-programmable-completion-tutorial)

# 1 - source this file for autocompletion

# 2 - to declare a static wordlist of autocompleteable words use:
### complete -W 'anvil hamr logika parser proyek slang presentasi server tools' sireum

# 3 - use complete -F with a function for programmable autocomplete

# 4 - use compgen to filter completion suggestions based on current input, i.e.
### compgen -W 'anvil hamr logika parser proyek slang presentasi server tools' pres

# 5 - use the following variables inside the complete function (note: DIRECT QUOTE)

###
# COMP_WORDS: an array of all the words typed after the name of the program the compspec belongs to
# COMP_CWORD: an index of the COMP_WORDS array pointing to the word the current cursor is at - in other words, the index of the word the cursor was when the tab key was pressed
# COMP_LINE: the current command line
###

_sireum_completions()
{

  # Dynamic example delegates autocomplete logic to Slang
  echo $(./sireum-completion-helper.cmd $COMP_LINE)
  # The slang code ran run like project.cmd, except writes the functions out (caches them). Probably too slow for autocomplete though. Unless we can access intellij's indexing somehow.

  # Faster dynamic example is pure shell script generated by cligen
  # TODO (this is ideal solution? that or we cache results of passing to helper)

  # Static example is simple and fast
  COMPREPLY+=('anvil')
  COMPREPLY+=('hamr')
  COMPREPLY+=('logika')
  COMPREPLY+=('parser')
  COMPREPLY+=('proyek')
  COMPREPLY+=('slang')
  COMPREPLY+=('presentasi')
  COMPREPLY+=('server')
  COMPREPLY+=('tools')
}

_sireum_anvil_completions()
{
  COMPREPLY+=('compile')
  COMPREPLY+=('sandbox')
}

_sireum() {
  local i=1 cmd

  while [[ "$i" -lt "$COMP_CWORD" ]]
  do
    local s="${COMP_WORDS[i]}"
    case "$s" in
      -*) ;;
      *)
        cmd="$s"
        break
        ;;
    esac
    (( i++ ))
  done

  if [[ "$i" -eq "$COMP_CWORD" ]]
  then
    local cur="${COMP_WORDS[COMP_CWORD]}"
    #COMPREPLY=($(compgen -W "plain subcommand subcommand2 --class-opt -h --help help" -- "$cur"))
    COMPREPLY=($(compgen -W "anvil hamr logika parser proyek slang presentasi server tools" -- "$cur"))
    return 
  fi

  case "$cmd" in
    plain) _main_plain ;;
    subcommand) _main_subcommand ;;
    subcommand2) _main_subcommand2 ;;
    *)          ;;
  esac

}

_print_args() {
  echo $COMP_WORDS
  echo $COMP_CWORD
  echo $COMP_LINE

    local cur prev
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    echo 'cur'
    echo "$cur"
    echo 'prev'
    echo "$cur"
}

_dynamic_autocomplete_test() {
  # Dynamic example delegates autocomplete logic to Slang
  echo $(./sireum-completion-helper.cmd $COMP_LINE)
  # The slang code ran run like project.cmd, except writes the functions out (caches them). Probably too slow for autocomplete though. Unless we can access intellij's indexing somehow.

  # Faster dynamic example is pure shell script generated by cligen
  # TODO (this is ideal solution? that or we cache results of passing to helper)

  # todo use for zsh?
  # compadd -S '' -a completions_array
}

_main() {
    COMPREPLY=()
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "${COMP_WORDS[1]}" in
      'anvil')
        case "${COMP_WORDS[2]}" in
          'compile')
              case "$prev" in
                '--stage')
                  COMPREPLY=($(compgen -W 'all hls hw sw os' -- "$cur"))
                  return
                ;;
                '--transpiler-args-file')
                  # Return file and directory listings by enabling default mode and sending empty.
                  COMPREPLY=($(compgen -f -- "$cur"))
                  return
                ;;
                '--sandbox-path')
                   # Return file and directory listings by enabling default mode and sending empty.
                   COMPREPLY=($(compgen -f -- "$cur"))
                   return
                 ;;
                *)
                  COMPREPLY=($(compgen -W '--stage --transpiler-args-file --sandbox-path org.example.gen#funList' -- "$cur"))
                  return
                  ;;
              esac
              ;;
          'sandbox')
              case "$prev" in
                '-x' | '--xilinx-unified-path')
                   # Return file and directory listings by enabling default mode and sending empty.
                   COMPREPLY=($(compgen -f -- "$cur"))
                   return
                ;;
                '-p' | '--petalinux-installer-path')
                   # Return file and directory listings by enabling default mode and sending empty.
                   COMPREPLY=($(compgen -f -- "$cur"))
                   return
                ;;
                '-s' | '--exclude-sireum' | *) # since exclude-sireum is flag, include with subcases
                  COMPREPLY=($(compgen -W '-x -p -s --xilinx-unified-path --petalinux-installer-path --exclude-sireum' -- "$cur"))
                  return
                ;;
              esac
              ;;
          *)
              COMPREPLY=($(compgen -W 'compile sandbox' -- "$cur"))
              return
              ;;
        esac
      ;;
      'hamr')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'logika')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'parser')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'proyek')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'slang')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'presentasi')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'server')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      'tools')
          # COMPREPLY=($(compgen -W 'todo' -- "$cur"))
          COMPREPLY=($(compgen -f -- "$cur"))
          return
      ;;
      *)
          COMPREPLY=($(compgen -W 'anvil hamr logika parser proyek slang presentasi server tools' -- "$cur"))
          return
      ;;
    esac


    #local cmds=('anvil' 'hamr' 'logika' 'parser' 'proyek' 'slang' 'presentasi' 'server' 'tools')
    COMPREPLY=($(compgen -W 'anvil hamr logika parser proyek slang presentasi server tools' -- "$cur"))
    return
}


_sireum_chomp()
{
  local cur prev

  COMPREPLY=()
  cur=${COMP_WORDS[COMP_CWORD]}
  prev=${COMP_WORDS[COMP_CWORD-1]}

  if [ $COMP_CWORD -eq 1 ]; then
    #COMPREPLY=( $(compgen -W "asadmin deploy" -- $cur) )
    COMPREPLY=($(compgen -W "anvil hamr logika parser proyek slang presentasi server tools" -- "$cur"))
  elif [ $COMP_CWORD -eq 2 ]; then
    case "$prev" in
      "asadmin")
        COMPREPLY=( $(compgen -W "start-domain stop-domain" -- $cur) )
        ;;
      "deploy")
        COMPREPLY=( $(compgen -W "all current" -- $cur) )
        ;;
      *)
        ;;
    esac
  fi

  return 0
}

#complete -F _sireum_anvil_completions sireum anvil
#complete -F _sireum_anvil_completions sireum anvil
complete -F _main sireum
